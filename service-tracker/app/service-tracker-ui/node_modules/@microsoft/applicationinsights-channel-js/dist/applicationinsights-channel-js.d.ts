/*
 * Microsoft Application Insights JavaScript SDK Channel, 2.6.2
 * Copyright (c) Microsoft and contributors. All rights reserved.
 *
 * Microsoft Application Insights Team
 * https://github.com/microsoft/ApplicationInsights-JS#readme
 */

declare namespace ApplicationInsights {
    import { BaseTelemetryPlugin } from '@microsoft/applicationinsights-core-js';
    import { IAppInsightsCore } from '@microsoft/applicationinsights-core-js';
    import { IChannelControlsAI } from '@microsoft/applicationinsights-common';
    import { IConfig } from '@microsoft/applicationinsights-common';
    import { IConfiguration } from '@microsoft/applicationinsights-core-js';
    import { IDiagnosticLogger } from '@microsoft/applicationinsights-core-js';
    import { IEnvelope } from '@microsoft/applicationinsights-common';
    import { IPlugin } from '@microsoft/applicationinsights-core-js';
    import { IProcessTelemetryContext } from '@microsoft/applicationinsights-core-js';
    import { ISample } from '@microsoft/applicationinsights-common';
    import { ITelemetryItem } from '@microsoft/applicationinsights-core-js';
    import { ITelemetryPluginChain } from '@microsoft/applicationinsights-core-js';
    import { SendRequestReason } from '@microsoft/applicationinsights-core-js';

    interface IBackendResponse {
        /**
         * Number of items received by the backend
         */
        itemsReceived: number;
        /**
         * Number of items succesfuly accepted by the backend
         */
        itemsAccepted: number;
        /**
         * List of errors for items which were not accepted
         */
        errors: IResponseError[];
        /**
         * App id returned by the backend - not necessary returned, but we don't need it with each response.
         */
        appId?: string;
    }

    interface IResponseError {
        index: number;
        statusCode: number;
        message: string;
    }

    interface ISendBuffer {
        /**
         * Enqueue the payload
         */
        enqueue: (payload: string) => void;
        /**
         * Returns the number of elements in the buffer
         */
        count: () => number;
        /**
         * Clears the buffer
         */
        clear: () => void;
        /**
         * Returns items stored in the buffer
         */
        getItems: () => string[];
        /**
         * Build a batch of all elements in the payload array
         */
        batchPayloads: (payload: string[]) => string;
        /**
         * Moves items to the SENT_BUFFER.
         * The buffer holds items which were sent, but we haven't received any response from the backend yet.
         */
        markAsSent: (payload: string[]) => void;
        /**
         * Removes items from the SENT_BUFFER. Should be called on successful response from the backend.
         */
        clearSent: (payload: string[]) => void;
    }

    interface ISenderConfig {
        /**
         * The url to which payloads will be sent
         */
        endpointUrl: () => string;
        /**
         * The JSON format (normal vs line delimited). True means line delimited JSON.
         */
        emitLineDelimitedJson: () => boolean;
        /**
         * The maximum size of a batch in bytes
         */
        maxBatchSizeInBytes: () => number;
        /**
         * The maximum interval allowed between calls to batchInvoke
         */
        maxBatchInterval: () => number;
        /**
         * The master off switch.  Do not send any data if set to TRUE
         */
        disableTelemetry: () => boolean;
        /**
         * Store a copy of a send buffer in the session storage
         */
        enableSessionStorageBuffer: () => boolean;
        /**
         * Is retry handler disabled.
         * If enabled, retry on 206 (partial success), 408 (timeout), 429 (too many requests), 500 (internal server error) and 503 (service unavailable).
         */
        isRetryDisabled: () => boolean;
        isBeaconApiDisabled: () => boolean;
        /**
         * Is beacon disabled on page unload.
         * If enabled, flush events through beaconSender.
         */
        onunloadDisableBeacon: () => boolean;
        /**
         * (Optional) Override the instrumentation key that this channel instance sends to
         */
        instrumentationKey: () => string;
        namePrefix: () => string;
        samplingPercentage: () => number;
    }

    class Sample implements ISample {
        sampleRate: number;
        INT_MAX_VALUE: number;
        private samplingScoreGenerator;
        private _logger;
        constructor(sampleRate: number, logger?: IDiagnosticLogger);
        /**
         * Determines if an envelope is sampled in (i.e. will be sent) or not (i.e. will be dropped).
         */
        isSampledIn(envelope: ITelemetryItem): boolean;
    }

    class Sender extends BaseTelemetryPlugin implements IChannelControlsAI {
        static constructEnvelope(orig: ITelemetryItem, iKey: string, logger: IDiagnosticLogger): IEnvelope;
        private static _getDefaultAppInsightsChannelConfig();
        private static _getEmptyAppInsightsChannelConfig();
        priority: number;
        identifier: string;
        /**
         * The configuration for this sender instance
         */
        _senderConfig: ISenderConfig;
        /**
         * A method which will cause data to be send to the url
         */
        _sender: SenderFunction;
        /**
         * A send buffer object
         */
        _buffer: ISendBuffer;
        /**
         * AppId of this component parsed from some backend response.
         */
        _appId: string;
        /**
         * Whether XMLHttpRequest object is supported. Older version of IE (8,9) do not support it.
         */
        _XMLHttpRequestSupported: boolean;
        protected _sample: Sample;
        constructor();
        pause(): void;
        resume(): void;
        flush(): void;
        onunloadFlush(): void;
        teardown(): void;
        initialize(config: IConfiguration & IConfig, core: IAppInsightsCore, extensions: IPlugin[], pluginChain?: ITelemetryPluginChain): void;
        processTelemetry(telemetryItem: ITelemetryItem, itemCtx?: IProcessTelemetryContext): void;
        /**
         * xhr state changes
         */
        _xhrReadyStateChange(xhr: XMLHttpRequest, payload: string[], countOfItemsInPayload: number): void;
        /**
         * Immediately send buffered data
         * @param async {boolean} - Indicates if the events should be sent asynchronously
         * @param forcedSender {SenderFunction} - Indicates the forcedSender, undefined if not passed
         */
        triggerSend(async?: boolean, forcedSender?: SenderFunction, sendReason?: SendRequestReason): void;
        /**
         * error handler
         */
        _onError(payload: string[], message: string, event?: ErrorEvent): void;
        /**
         * partial success handler
         */
        _onPartialSuccess(payload: string[], results: IBackendResponse): void;
        /**
         * success handler
         */
        _onSuccess(payload: string[], countOfItemsInPayload: number): void;
        /**
         * xdr state changes
         */
        _xdrOnLoad(xdr: XDomainRequest, payload: string[]): void;
    }

    type SenderFunction = (payload: string[], isAsync: boolean) => void;

    interface XDomainRequest extends XMLHttpRequestEventTarget {
        responseText: string;
        send(payload: string): void;
        open(method: string, url: string): void;
    }

    
}